package reshy.util

import com.google.api.client.auth.oauth2.Credential
import com.google.api.client.extensions.java6.auth.oauth2.AuthorizationCodeInstalledApp
import com.google.api.client.extensions.jetty.auth.oauth2.LocalServerReceiver
import com.google.api.client.googleapis.auth.oauth2.GoogleAuthorizationCodeFlow
import com.google.api.client.googleapis.auth.oauth2.GoogleClientSecrets
import com.google.api.client.googleapis.javanet.GoogleNetHttpTransport
import com.google.api.client.http.HttpTransport
import com.google.api.client.json.jackson2.JacksonFactory
import com.google.api.client.json.JsonFactory
import com.google.api.client.util.store.FileDataStoreFactory
import com.google.api.client.http.HttpRequestInitializer
import com.google.api.client.http.HttpRequest

import com.google.api.services.script.Script

class SpreadsheetConnecter {

//    private static final String ID = '389663495913-pdrbfhmkch1pblm3poetuui6fphth0gc.apps.googleusercontent.com'
//    private static final String SECRET = 'HMZx1ViH8rKeqkovn7dClk_9'
    private static final String APP_NAME = 'Reshy'

    private static final File DATA_STORE_DIR = new File(System.getProperty('user.home'), '.credentials/reshy.json')

    private static FileDataStoreFactory DATA_STORE_FACTORY

    private static final JsonFactory JSON_FACTORY = JacksonFactory.getDefaultInstance()

    private static HttpTransport HTTP_TRANSPORT

    private static final List<String> SCOPES = ['https://www.googleapis.com/auth/drive']

    static {
        try {
            HTTP_TRANSPORT = GoogleNetHttpTransport.newTrustedTransport()
            DATA_STORE_FACTORY = new FileDataStoreFactory(DATA_STORE_DIR)
        } catch (Throwable t) {
            t.printStackTrace()
            println 'Could not create either HTTP transport or data store factory.'
        }
    }

    /**
     * Creates an authorized Credential object.
     * @return an authorized Credential object.
     * @throws IOException
     */
    public static Credential authorize() throws IOException {
        // Load client secrets.
        InputStream input = SpreadsheetConnecter.class.getResourceAsStream("/client_secret.json")
        GoogleClientSecrets clientSecrets = GoogleClientSecrets.load(JSON_FACTORY, new InputStreamReader(input))

        // Build flow and trigger user authorization request.
        GoogleAuthorizationCodeFlow flow = new GoogleAuthorizationCodeFlow.Builder(HTTP_TRANSPORT, JSON_FACTORY, clientSecrets, SCOPES).setDataStoreFactory(DATA_STORE_FACTORY).setAccessType("offline").build()
        Credential credential = new AuthorizationCodeInstalledApp(flow, new LocalServerReceiver()).authorize("user")
        println("Credentials saved to ${DATA_STORE_DIR.getAbsolutePath()}")
        return credential
    }

    /**
     * Create a HttpRequestInitializer from the given one, except set
     * the HTTP read timeout to be longer than the default (to allow
     * called scripts time to execute).
     *
     * @param {HttpRequestInitializer} requestInitializer the initializer
     *     to copy and adjust; typically a Credential object.
     * @return an initializer with an extended read timeout.
     */
    private static HttpRequestInitializer setHttpTimeout(final HttpRequestInitializer requestInitializer) {
        return new HttpRequestInitializer() {
            @Override
            public void initialize(HttpRequest httpRequest) throws IOException {
                requestInitializer.initialize(httpRequest)
                // This allows the API to call (and avoid timing out on) functions that take up to 6 minutes to complete (the maximum allowed script run time), plus a little overhead.
                httpRequest.setReadTimeout(380000)
            }
        }
    }

    /**
     * Build and return an authorized Script client service.
     *
     * @param {Credential} credential an authorized Credential object
     * @return an authorized Script client service
     */
    public static Script getScriptService() throws IOException {
        Credential credential = authorize()
        return new Script.Builder(HTTP_TRANSPORT, JSON_FACTORY, setHttpTimeout(credential)).setApplicationName(APPLICATION_NAME).build()
    }

    /**
     * Interpret an error response returned by the API and return a String
     * summary.
     *
     * @param {Operation} op the Operation returning an error response
     * @return summary of error response, or null if Operation returned no error
     */
    public static String getScriptError(Operation op) {
        if (op.getError() == null) {
            return null
        }

        // Extract the first (and only) set of error details and cast as a Map.
        // The values of this map are the script's 'errorMessage' and
        // 'errorType', and an array of stack trace elements (which also need to
        // be cast as Maps).
        Map<String, Object> detail = op.getError().getDetails().get(0)
        List<Map<String, Object>> stacktrace =
                (List<Map<String, Object>>)detail.get("scriptStackTraceElements")

        StringBuilder sb = new StringBuilder("\nScript error message: ")
        sb.append(detail.get("errorMessage"))
        sb.append("\nScript error type: ")
        sb.append(detail.get("errorType"))

        if (stacktrace != null) {
            // There may not be a stacktrace if the script didn't start
            // executing.
            sb.append("\nScript error stacktrace:")
            sb.append(stacktrace.collect { "  ${it.function}:${it.lineNumber}" }.join('\n'))
        }
        sb.append("\n")
        return sb.toString()
    }
}